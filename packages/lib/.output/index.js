// @bun
import*as r from"crypto";var J$=r&&typeof r==="object"&&"webcrypto"in r?r.webcrypto:r&&typeof r==="object"&&("randomBytes"in r)?r:void 0;/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */function Z$($){return $ instanceof Uint8Array||ArrayBuffer.isView($)&&$.constructor.name==="Uint8Array"}function C$($){if(!Number.isSafeInteger($)||$<0)throw new Error("positive integer expected, got "+$)}function _($,...Q){if(!Z$($))throw new Error("Uint8Array expected");if(Q.length>0&&!Q.includes($.length))throw new Error("Uint8Array expected of length "+Q+", got length="+$.length)}function t$($){if(typeof $!=="function"||typeof $.create!=="function")throw new Error("Hash should be wrapped by utils.createHasher");C$($.outputLen),C$($.blockLen)}function j$($,Q=!0){if($.destroyed)throw new Error("Hash instance has been destroyed");if(Q&&$.finished)throw new Error("Hash#digest() has already been called")}function e$($,Q){_($);let J=Q.outputLen;if($.length<J)throw new Error("digestInto() expects output buffer of length at least "+J)}function Q$(...$){for(let Q=0;Q<$.length;Q++)$[Q].fill(0)}function P$($){return new DataView($.buffer,$.byteOffset,$.byteLength)}function c($,Q){return $<<32-Q|$>>>Q}var $0=(()=>typeof Uint8Array.from([]).toHex==="function"&&typeof Uint8Array.fromHex==="function")(),m0=Array.from({length:256},($,Q)=>Q.toString(16).padStart(2,"0"));function n($){if(_($),$0)return $.toHex();let Q="";for(let J=0;J<$.length;J++)Q+=m0[$[J]];return Q}var o={_0:48,_9:57,A:65,F:70,a:97,f:102};function s$($){if($>=o._0&&$<=o._9)return $-o._0;if($>=o.A&&$<=o.F)return $-(o.A-10);if($>=o.a&&$<=o.f)return $-(o.a-10);return}function D$($){if(typeof $!=="string")throw new Error("hex string expected, got "+typeof $);if($0)return Uint8Array.fromHex($);let Q=$.length,J=Q/2;if(Q%2)throw new Error("hex string expected, got unpadded hex of length "+Q);let G=new Uint8Array(J);for(let X=0,q=0;X<J;X++,q+=2){let Y=s$($.charCodeAt(q)),M=s$($.charCodeAt(q+1));if(Y===void 0||M===void 0){let N=$[q]+$[q+1];throw new Error('hex string expected, got non-hex character "'+N+'" at index '+q)}G[X]=Y*16+M}return G}function J0($){if(typeof $!=="string")throw new Error("string expected");return new Uint8Array(new TextEncoder().encode($))}function V$($){if(typeof $==="string")$=J0($);return _($),$}function h(...$){let Q=0;for(let G=0;G<$.length;G++){let X=$[G];_(X),Q+=X.length}let J=new Uint8Array(Q);for(let G=0,X=0;G<$.length;G++){let q=$[G];J.set(q,X),X+=q.length}return J}class B${}function Q0($){let Q=(G)=>$().update(V$(G)).digest(),J=$();return Q.outputLen=J.outputLen,Q.blockLen=J.blockLen,Q.create=()=>$(),Q}function b$($=32){if(J$&&typeof J$.getRandomValues==="function")return J$.getRandomValues(new Uint8Array($));if(J$&&typeof J$.randomBytes==="function")return Uint8Array.from(J$.randomBytes($));throw new Error("crypto.getRandomValues must be defined")}function u0($,Q,J,G){if(typeof $.setBigUint64==="function")return $.setBigUint64(Q,J,G);let X=BigInt(32),q=BigInt(4294967295),Y=Number(J>>X&q),M=Number(J&q),N=G?4:0,D=G?0:4;$.setUint32(Q+N,Y,G),$.setUint32(Q+D,M,G)}function G0($,Q,J){return $&Q^~$&J}function q0($,Q,J){return $&Q^$&J^Q&J}class y$ extends B${constructor($,Q,J,G){super();this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.blockLen=$,this.outputLen=Q,this.padOffset=J,this.isLE=G,this.buffer=new Uint8Array($),this.view=P$(this.buffer)}update($){j$(this),$=V$($),_($);let{view:Q,buffer:J,blockLen:G}=this,X=$.length;for(let q=0;q<X;){let Y=Math.min(G-this.pos,X-q);if(Y===G){let M=P$($);for(;G<=X-q;q+=G)this.process(M,q);continue}if(J.set($.subarray(q,q+Y),this.pos),this.pos+=Y,q+=Y,this.pos===G)this.process(Q,0),this.pos=0}return this.length+=$.length,this.roundClean(),this}digestInto($){j$(this),e$($,this),this.finished=!0;let{buffer:Q,view:J,blockLen:G,isLE:X}=this,{pos:q}=this;if(Q[q++]=128,Q$(this.buffer.subarray(q)),this.padOffset>G-q)this.process(J,0),q=0;for(let K=q;K<G;K++)Q[K]=0;u0(J,G-8,BigInt(this.length*8),X),this.process(J,0);let Y=P$($),M=this.outputLen;if(M%4)throw new Error("_sha2: outputLen should be aligned to 32bit");let N=M/4,D=this.get();if(N>D.length)throw new Error("_sha2: outputLen bigger than state");for(let K=0;K<N;K++)Y.setUint32(4*K,D[K],X)}digest(){let{buffer:$,outputLen:Q}=this;this.digestInto($);let J=$.slice(0,Q);return this.destroy(),J}_cloneInto($){$||($=new this.constructor),$.set(...this.get());let{blockLen:Q,buffer:J,length:G,finished:X,destroyed:q,pos:Y}=this;if($.destroyed=q,$.finished=X,$.length=G,$.pos=Y,G%Q)$.buffer.set(J);return $}clone(){return this._cloneInto()}}var i=Uint32Array.from([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]);var d0=Uint32Array.from([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),s=new Uint32Array(64);class X0 extends y${constructor($=32){super(64,$,8,!1);this.A=i[0]|0,this.B=i[1]|0,this.C=i[2]|0,this.D=i[3]|0,this.E=i[4]|0,this.F=i[5]|0,this.G=i[6]|0,this.H=i[7]|0}get(){let{A:$,B:Q,C:J,D:G,E:X,F:q,G:Y,H:M}=this;return[$,Q,J,G,X,q,Y,M]}set($,Q,J,G,X,q,Y,M){this.A=$|0,this.B=Q|0,this.C=J|0,this.D=G|0,this.E=X|0,this.F=q|0,this.G=Y|0,this.H=M|0}process($,Q){for(let K=0;K<16;K++,Q+=4)s[K]=$.getUint32(Q,!1);for(let K=16;K<64;K++){let W=s[K-15],V=s[K-2],R=c(W,7)^c(W,18)^W>>>3,L=c(V,17)^c(V,19)^V>>>10;s[K]=L+s[K-7]+R+s[K-16]|0}let{A:J,B:G,C:X,D:q,E:Y,F:M,G:N,H:D}=this;for(let K=0;K<64;K++){let W=c(Y,6)^c(Y,11)^c(Y,25),V=D+W+G0(Y,M,N)+d0[K]+s[K]|0,L=(c(J,2)^c(J,13)^c(J,22))+q0(J,G,X)|0;D=N,N=M,M=Y,Y=q+V|0,q=X,X=G,G=J,J=V+L|0}J=J+this.A|0,G=G+this.B|0,X=X+this.C|0,q=q+this.D|0,Y=Y+this.E|0,M=M+this.F|0,N=N+this.G|0,D=D+this.H|0,this.set(J,G,X,q,Y,M,N,D)}roundClean(){Q$(s)}destroy(){this.set(0,0,0,0,0,0,0,0),Q$(this.buffer)}}var Y0=Q0(()=>new X0);class v$ extends B${constructor($,Q){super();this.finished=!1,this.destroyed=!1,t$($);let J=V$(Q);if(this.iHash=$.create(),typeof this.iHash.update!=="function")throw new Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;let G=this.blockLen,X=new Uint8Array(G);X.set(J.length>G?$.create().update(J).digest():J);for(let q=0;q<X.length;q++)X[q]^=54;this.iHash.update(X),this.oHash=$.create();for(let q=0;q<X.length;q++)X[q]^=106;this.oHash.update(X),Q$(X)}update($){return j$(this),this.iHash.update($),this}digestInto($){j$(this),_($,this.outputLen),this.finished=!0,this.iHash.digestInto($),this.oHash.update($),this.oHash.digestInto($),this.destroy()}digest(){let $=new Uint8Array(this.oHash.outputLen);return this.digestInto($),$}_cloneInto($){$||($=Object.create(Object.getPrototypeOf(this),{}));let{oHash:Q,iHash:J,finished:G,destroyed:X,blockLen:q,outputLen:Y}=this;return $=$,$.finished=G,$.destroyed=X,$.blockLen=q,$.outputLen=Y,$.oHash=Q._cloneInto($.oHash),$.iHash=J._cloneInto($.iHash),$}clone(){return this._cloneInto()}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}}var _$=($,Q,J)=>new v$($,Q).update(J).digest();_$.create=($,Q)=>new v$($,Q);/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */var d$=BigInt(0),u$=BigInt(1);function A$($,Q){if(typeof Q!=="boolean")throw new Error($+" boolean expected, got "+Q)}function x$($){let Q=$.toString(16);return Q.length&1?"0"+Q:Q}function K0($){if(typeof $!=="string")throw new Error("hex string expected, got "+typeof $);return $===""?d$:BigInt("0x"+$)}function U$($){return K0(n($))}function l$($){return _($),K0(n(Uint8Array.from($).reverse()))}function S$($,Q){return D$($.toString(16).padStart(Q*2,"0"))}function F$($,Q){return S$($,Q).reverse()}function m($,Q,J){let G;if(typeof Q==="string")try{G=D$(Q)}catch(q){throw new Error($+" must be hex string or Uint8Array, cause: "+q)}else if(Z$(Q))G=Uint8Array.from(Q);else throw new Error($+" must be hex string or Uint8Array");let X=G.length;if(typeof J==="number"&&X!==J)throw new Error($+" of length "+J+" expected, got "+X);return G}var m$=($)=>typeof $==="bigint"&&d$<=$;function M0($,Q,J){return m$($)&&m$(Q)&&m$(J)&&Q<=$&&$<J}function N0($,Q,J,G){if(!M0(Q,J,G))throw new Error("expected valid "+$+": "+J+" <= n < "+G+", got "+Q)}function z0($){let Q;for(Q=0;$>d$;$>>=u$,Q+=1);return Q}var G$=($)=>(u$<<BigInt($))-u$;function Z0($,Q,J){if(typeof $!=="number"||$<2)throw new Error("hashLen must be a number");if(typeof Q!=="number"||Q<2)throw new Error("qByteLen must be a number");if(typeof J!=="function")throw new Error("hmacFn must be a function");let G=(R)=>new Uint8Array(R),X=(R)=>Uint8Array.of(R),q=G($),Y=G($),M=0,N=()=>{q.fill(1),Y.fill(0),M=0},D=(...R)=>J(Y,q,...R),K=(R=G(0))=>{if(Y=D(X(0),R),q=D(),R.length===0)return;Y=D(X(1),R),q=D()},W=()=>{if(M++>=1000)throw new Error("drbg: tried 1000 values");let R=0,L=[];while(R<Q){q=D();let H=q.slice();L.push(H),R+=q.length}return h(...L)};return(R,L)=>{N(),K(R);let H=void 0;while(!(H=L(W())))K();return N(),H}}function R$($,Q,J={}){if(!$||typeof $!=="object")throw new Error("expected valid options object");function G(X,q,Y){let M=$[X];if(Y&&M===void 0)return;let N=typeof M;if(N!==q||M===null)throw new Error(`param "${X}" is invalid: expected ${q}, got ${N}`)}Object.entries(Q).forEach(([X,q])=>G(X,q,!1)),Object.entries(J).forEach(([X,q])=>G(X,q,!0))}function c$($){let Q=new WeakMap;return(J,...G)=>{let X=Q.get(J);if(X!==void 0)return X;let q=$(J,...G);return Q.set(J,q),q}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */var v=BigInt(0),y=BigInt(1),q$=BigInt(2),l0=BigInt(3),U0=BigInt(4),I0=BigInt(5),T0=BigInt(8);function d($,Q){let J=$%Q;return J>=v?J:Q+J}function l($,Q,J){let G=$;while(Q-- >v)G*=G,G%=J;return G}function j0($,Q){if($===v)throw new Error("invert: expected non-zero number");if(Q<=v)throw new Error("invert: expected positive modulus, got "+Q);let J=d($,Q),G=Q,X=v,q=y,Y=y,M=v;while(J!==v){let D=G/J,K=G%J,W=X-Y*D,V=q-M*D;G=J,J=K,X=Y,q=M,Y=W,M=V}if(G!==y)throw new Error("invert: does not exist");return d(X,Q)}function W0($,Q){let J=($.ORDER+y)/U0,G=$.pow(Q,J);if(!$.eql($.sqr(G),Q))throw new Error("Cannot find square root");return G}function F0($,Q){let J=($.ORDER-I0)/T0,G=$.mul(Q,q$),X=$.pow(G,J),q=$.mul(Q,X),Y=$.mul($.mul(q,q$),X),M=$.mul(q,$.sub(Y,$.ONE));if(!$.eql($.sqr(M),Q))throw new Error("Cannot find square root");return M}function c0($){if($<BigInt(3))throw new Error("sqrt is not defined for small field");let Q=$-y,J=0;while(Q%q$===v)Q/=q$,J++;let G=q$,X=X$($);while(D0(X,G)===1)if(G++>1000)throw new Error("Cannot find square root: probably non-prime P");if(J===1)return W0;let q=X.pow(G,Q),Y=(Q+y)/q$;return function M(N,D){if(N.is0(D))return D;if(D0(N,D)!==1)throw new Error("Cannot find square root");let K=J,W=N.mul(N.ONE,q),V=N.pow(D,Q),R=N.pow(D,Y);while(!N.eql(V,N.ONE)){if(N.is0(V))return N.ZERO;let L=1,H=N.sqr(V);while(!N.eql(H,N.ONE))if(L++,H=N.sqr(H),L===K)throw new Error("Cannot find square root");let g=y<<BigInt(K-L-1),F=N.pow(W,g);K=L,W=N.sqr(F),V=N.mul(V,W),R=N.mul(R,F)}return R}}function h0($){if($%U0===l0)return W0;if($%T0===I0)return F0;return c0($)}var r0=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function h$($){let Q={ORDER:"bigint",MASK:"bigint",BYTES:"number",BITS:"number"},J=r0.reduce((G,X)=>{return G[X]="function",G},Q);return R$($,J),$}function o0($,Q,J){if(J<v)throw new Error("invalid exponent, negatives unsupported");if(J===v)return $.ONE;if(J===y)return Q;let G=$.ONE,X=Q;while(J>v){if(J&y)G=$.mul(G,X);X=$.sqr(X),J>>=y}return G}function f$($,Q,J=!1){let G=new Array(Q.length).fill(J?$.ZERO:void 0),X=Q.reduce((Y,M,N)=>{if($.is0(M))return Y;return G[N]=Y,$.mul(Y,M)},$.ONE),q=$.inv(X);return Q.reduceRight((Y,M,N)=>{if($.is0(M))return Y;return G[N]=$.mul(Y,G[N]),$.mul(Y,M)},q),G}function D0($,Q){let J=($.ORDER-y)/q$,G=$.pow(Q,J),X=$.eql(G,$.ONE),q=$.eql(G,$.ZERO),Y=$.eql(G,$.neg($.ONE));if(!X&&!q&&!Y)throw new Error("invalid Legendre symbol result");return X?1:q?0:-1}function C0($,Q){if(Q!==void 0)C$(Q);let J=Q!==void 0?Q:$.toString(2).length,G=Math.ceil(J/8);return{nBitLength:J,nByteLength:G}}function X$($,Q,J=!1,G={}){if($<=v)throw new Error("invalid field: expected ORDER > 0, got "+$);let X=void 0,q=void 0;if(typeof Q==="object"&&Q!=null){if(G.sqrt||J)throw new Error("cannot specify opts in two arguments");let K=Q;if(K.BITS)X=K.BITS;if(K.sqrt)q=K.sqrt;if(typeof K.isLE==="boolean")J=K.isLE}else{if(typeof Q==="number")X=Q;if(G.sqrt)q=G.sqrt}let{nBitLength:Y,nByteLength:M}=C0($,X);if(M>2048)throw new Error("invalid field: expected ORDER of <= 2048 bytes");let N,D=Object.freeze({ORDER:$,isLE:J,BITS:Y,BYTES:M,MASK:G$(Y),ZERO:v,ONE:y,create:(K)=>d(K,$),isValid:(K)=>{if(typeof K!=="bigint")throw new Error("invalid field element: expected bigint, got "+typeof K);return v<=K&&K<$},is0:(K)=>K===v,isValidNot0:(K)=>!D.is0(K)&&D.isValid(K),isOdd:(K)=>(K&y)===y,neg:(K)=>d(-K,$),eql:(K,W)=>K===W,sqr:(K)=>d(K*K,$),add:(K,W)=>d(K+W,$),sub:(K,W)=>d(K-W,$),mul:(K,W)=>d(K*W,$),pow:(K,W)=>o0(D,K,W),div:(K,W)=>d(K*j0(W,$),$),sqrN:(K)=>K*K,addN:(K,W)=>K+W,subN:(K,W)=>K-W,mulN:(K,W)=>K*W,inv:(K)=>j0(K,$),sqrt:q||((K)=>{if(!N)N=h0($);return N(D,K)}),toBytes:(K)=>J?F$(K,M):S$(K,M),fromBytes:(K)=>{if(K.length!==M)throw new Error("Field.fromBytes: expected "+M+" bytes, got "+K.length);return J?l$(K):U$(K)},invertBatch:(K)=>f$(D,K),cmov:(K,W,V)=>V?W:K});return Object.freeze(D)}function V0($){if(typeof $!=="bigint")throw new Error("field order must be bigint");let Q=$.toString(2).length;return Math.ceil(Q/8)}function r$($){let Q=V0($);return Q+Math.ceil(Q/2)}function B0($,Q,J=!1){let G=$.length,X=V0(Q),q=r$(Q);if(G<16||G<q||G>1024)throw new Error("expected "+q+"-1024 bytes of input, got "+G);let Y=J?l$($):U$($),M=d(Y,Q-y)+y;return J?F$(M,X):S$(M,X)}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */var T$=BigInt(0),Y$=BigInt(1);function I$($,Q){let J=Q.negate();return $?J:Q}function O0($,Q,J){let G=Q==="pz"?(Y)=>Y.pz:(Y)=>Y.ez,X=f$($.Fp,J.map(G));return J.map((Y,M)=>Y.toAffine(X[M])).map($.fromAffine)}function k0($,Q){if(!Number.isSafeInteger($)||$<=0||$>Q)throw new Error("invalid window size, expected [1.."+Q+"], got W="+$)}function o$($,Q){k0($,Q);let J=Math.ceil(Q/$)+1,G=2**($-1),X=2**$,q=G$($),Y=BigInt($);return{windows:J,windowSize:G,mask:q,maxNumber:X,shiftBy:Y}}function A0($,Q,J){let{windowSize:G,mask:X,maxNumber:q,shiftBy:Y}=J,M=Number($&X),N=$>>Y;if(M>G)M-=q,N+=Y$;let D=Q*G,K=D+Math.abs(M)-1,W=M===0,V=M<0,R=Q%2!==0;return{nextN:N,offset:K,isZero:W,isNeg:V,isNegF:R,offsetF:D}}function i0($,Q){if(!Array.isArray($))throw new Error("array expected");$.forEach((J,G)=>{if(!(J instanceof Q))throw new Error("invalid point at index "+G)})}function a0($,Q){if(!Array.isArray($))throw new Error("array of scalars expected");$.forEach((J,G)=>{if(!Q.isValid(J))throw new Error("invalid scalar at index "+G)})}var i$=new WeakMap,L0=new WeakMap;function a$($){return L0.get($)||1}function x0($){if($!==T$)throw new Error("invalid wNAF")}function H0($,Q){return{constTimeNegate:I$,hasPrecomputes(J){return a$(J)!==1},unsafeLadder(J,G,X=$.ZERO){let q=J;while(G>T$){if(G&Y$)X=X.add(q);q=q.double(),G>>=Y$}return X},precomputeWindow(J,G){let{windows:X,windowSize:q}=o$(G,Q),Y=[],M=J,N=M;for(let D=0;D<X;D++){N=M,Y.push(N);for(let K=1;K<q;K++)N=N.add(M),Y.push(N);M=N.double()}return Y},wNAF(J,G,X){let{ZERO:q,BASE:Y}=$,M=o$(J,Q);for(let N=0;N<M.windows;N++){let{nextN:D,offset:K,isZero:W,isNeg:V,isNegF:R,offsetF:L}=A0(X,N,M);if(X=D,W)Y=Y.add(I$(R,G[L]));else q=q.add(I$(V,G[K]))}return x0(X),{p:q,f:Y}},wNAFUnsafe(J,G,X,q=$.ZERO){let Y=o$(J,Q);for(let M=0;M<Y.windows;M++){if(X===T$)break;let{nextN:N,offset:D,isZero:K,isNeg:W}=A0(X,M,Y);if(X=N,K)continue;else{let V=G[D];q=q.add(W?V.negate():V)}}return x0(X),q},getPrecomputes(J,G,X){let q=i$.get(G);if(!q){if(q=this.precomputeWindow(G,J),J!==1){if(typeof X==="function")q=X(q);i$.set(G,q)}}return q},wNAFCached(J,G,X){let q=a$(J);return this.wNAF(q,this.getPrecomputes(q,J,X),G)},wNAFCachedUnsafe(J,G,X,q){let Y=a$(J);if(Y===1)return this.unsafeLadder(J,G,q);return this.wNAFUnsafe(Y,this.getPrecomputes(Y,J,X),G,q)},setWindowSize(J,G){k0(G,Q),L0.set(J,G),i$.delete(J)}}}function P0($,Q,J,G){let X=Q,q=$.ZERO,Y=$.ZERO;while(J>T$||G>T$){if(J&Y$)q=q.add(X);if(G&Y$)Y=Y.add(X);X=X.double(),J>>=Y$,G>>=Y$}return{p1:q,p2:Y}}function S0($,Q,J,G){i0(J,$),a0(G,Q);let X=J.length,q=G.length;if(X!==q)throw new Error("arrays of points and scalars must have equal length");let Y=$.ZERO,M=z0(BigInt(X)),N=1;if(M>12)N=M-3;else if(M>4)N=M-2;else if(M>0)N=2;let D=G$(N),K=new Array(Number(D)+1).fill(Y),W=Math.floor((Q.BITS-1)/N)*N,V=Y;for(let R=W;R>=0;R-=N){K.fill(Y);for(let H=0;H<q;H++){let g=G[H],F=Number(g>>BigInt(R)&D);K[F]=K[F].add(J[H])}let L=Y;for(let H=K.length-1,g=Y;H>0;H--)g=g.add(K[H]),L=L.add(g);if(V=V.add(L),R!==0)for(let H=0;H<N;H++)V=V.double()}return V}function R0($,Q){if(Q){if(Q.ORDER!==$)throw new Error("Field.ORDER must match order: Fp == p, Fn == n");return h$(Q),Q}else return X$($)}function f0($,Q,J={}){if(!Q||typeof Q!=="object")throw new Error(`expected valid ${$} CURVE object`);for(let M of["p","n","h"]){let N=Q[M];if(!(typeof N==="bigint"&&N>T$))throw new Error(`CURVE.${M} must be positive bigint`)}let G=R0(Q.p,J.Fp),X=R0(Q.n,J.Fn),Y=["Gx","Gy","a",$==="weierstrass"?"b":"d"];for(let M of Y)if(!G.isValid(Q[M]))throw new Error(`CURVE.${M} must be valid field element of CURVE.Fp`);return{Fp:G,Fn:X}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */function w0($){if($.lowS!==void 0)A$("lowS",$.lowS);if($.prehash!==void 0)A$("prehash",$.prehash)}class E0 extends Error{constructor($=""){super($)}}var a={Err:E0,_tlv:{encode:($,Q)=>{let{Err:J}=a;if($<0||$>256)throw new J("tlv.encode: wrong tag");if(Q.length&1)throw new J("tlv.encode: unpadded data");let G=Q.length/2,X=x$(G);if(X.length/2&128)throw new J("tlv.encode: long form length too big");let q=G>127?x$(X.length/2|128):"";return x$($)+q+X+Q},decode($,Q){let{Err:J}=a,G=0;if($<0||$>256)throw new J("tlv.encode: wrong tag");if(Q.length<2||Q[G++]!==$)throw new J("tlv.decode: wrong tlv");let X=Q[G++],q=!!(X&128),Y=0;if(!q)Y=X;else{let N=X&127;if(!N)throw new J("tlv.decode(long): indefinite length not supported");if(N>4)throw new J("tlv.decode(long): byte length is too big");let D=Q.subarray(G,G+N);if(D.length!==N)throw new J("tlv.decode: length bytes not complete");if(D[0]===0)throw new J("tlv.decode(long): zero leftmost byte");for(let K of D)Y=Y<<8|K;if(G+=N,Y<128)throw new J("tlv.decode(long): not minimal encoding")}let M=Q.subarray(G,G+Y);if(M.length!==Y)throw new J("tlv.decode: wrong value length");return{v:M,l:Q.subarray(G+Y)}}},_int:{encode($){let{Err:Q}=a;if($<O$)throw new Q("integer: negative integers are not allowed");let J=x$($);if(Number.parseInt(J[0],16)&8)J="00"+J;if(J.length&1)throw new Q("unexpected DER parsing assertion: unpadded hex");return J},decode($){let{Err:Q}=a;if($[0]&128)throw new Q("invalid signature integer: negative");if($[0]===0&&!($[1]&128))throw new Q("invalid signature integer: unnecessary leading zero");return U$($)}},toSig($){let{Err:Q,_int:J,_tlv:G}=a,X=m("signature",$),{v:q,l:Y}=G.decode(48,X);if(Y.length)throw new Q("invalid signature: left bytes after parsing");let{v:M,l:N}=G.decode(2,q),{v:D,l:K}=G.decode(2,N);if(K.length)throw new Q("invalid signature: left bytes after parsing");return{r:J.decode(M),s:J.decode(D)}},hexFromSig($){let{_tlv:Q,_int:J}=a,G=Q.encode(2,J.encode($.r)),X=Q.encode(2,J.encode($.s)),q=G+X;return Q.encode(48,q)}},O$=BigInt(0),k$=BigInt(1),p0=BigInt(2),w$=BigInt(3),n0=BigInt(4);function s0($,Q,J){function G(X){let q=$.sqr(X),Y=$.mul(q,X);return $.add($.add(Y,$.mul(X,Q)),J)}return G}function g0($,Q,J){let{BYTES:G}=$;function X(q){let Y;if(typeof q==="bigint")Y=q;else{let M=m("private key",q);if(Q){if(!Q.includes(M.length*2))throw new Error("invalid private key");let N=new Uint8Array(G);N.set(M,N.length-M.length),M=N}try{Y=$.fromBytes(M)}catch(N){throw new Error(`invalid private key: expected ui8a of size ${G}, got ${typeof q}`)}}if(J)Y=$.create(Y);if(!$.isValidNot0(Y))throw new Error("invalid private key: out of range [1..N-1]");return Y}return X}function t0($,Q={}){let{Fp:J,Fn:G}=f0("weierstrass",$,Q),{h:X,n:q}=$;R$(Q,{},{allowInfinityPoint:"boolean",clearCofactor:"function",isTorsionFree:"function",fromBytes:"function",toBytes:"function",endo:"object",wrapPrivateKey:"boolean"});let{endo:Y}=Q;if(Y){if(!J.is0($.a)||typeof Y.beta!=="bigint"||typeof Y.splitScalar!=="function")throw new Error('invalid endo: expected "beta": bigint and "splitScalar": function')}function M(){if(!J.isOdd)throw new Error("compression is not supported: Field does not have .isOdd()")}function N(Z,I,C){let{x:z,y:j}=I.toAffine(),T=J.toBytes(z);if(A$("isCompressed",C),C){M();let B=!J.isOdd(j);return h(b0(B),T)}else return h(Uint8Array.of(4),T,J.toBytes(j))}function D(Z){_(Z);let I=J.BYTES,C=I+1,z=2*I+1,j=Z.length,T=Z[0],B=Z.subarray(1);if(j===C&&(T===2||T===3)){let U=J.fromBytes(B);if(!J.isValid(U))throw new Error("bad point: is not on curve, wrong x");let A=V(U),x;try{x=J.sqrt(A)}catch(O){let f=O instanceof Error?": "+O.message:"";throw new Error("bad point: is not on curve, sqrt error"+f)}M();let w=J.isOdd(x);if((T&1)===1!==w)x=J.neg(x);return{x:U,y:x}}else if(j===z&&T===4){let U=J.fromBytes(B.subarray(I*0,I*1)),A=J.fromBytes(B.subarray(I*1,I*2));if(!R(U,A))throw new Error("bad point: is not on curve");return{x:U,y:A}}else throw new Error(`bad point: got length ${j}, expected compressed=${C} or uncompressed=${z}`)}let K=Q.toBytes||N,W=Q.fromBytes||D,V=s0(J,$.a,$.b);function R(Z,I){let C=J.sqr(I),z=V(Z);return J.eql(C,z)}if(!R($.Gx,$.Gy))throw new Error("bad curve params: generator point");let L=J.mul(J.pow($.a,w$),n0),H=J.mul(J.sqr($.b),BigInt(27));if(J.is0(J.add(L,H)))throw new Error("bad curve params: a or b");function g(Z,I,C=!1){if(!J.isValid(I)||C&&J.is0(I))throw new Error(`bad point coordinate ${Z}`);return I}function F(Z){if(!(Z instanceof k))throw new Error("ProjectivePoint expected")}let K$=c$((Z,I)=>{let{px:C,py:z,pz:j}=Z;if(J.eql(j,J.ONE))return{x:C,y:z};let T=Z.is0();if(I==null)I=T?J.ONE:J.inv(j);let B=J.mul(C,I),U=J.mul(z,I),A=J.mul(j,I);if(T)return{x:J.ZERO,y:J.ZERO};if(!J.eql(A,J.ONE))throw new Error("invZ was invalid");return{x:B,y:U}}),t=c$((Z)=>{if(Z.is0()){if(Q.allowInfinityPoint&&!J.is0(Z.py))return;throw new Error("bad point: ZERO")}let{x:I,y:C}=Z.toAffine();if(!J.isValid(I)||!J.isValid(C))throw new Error("bad point: x or y not field elements");if(!R(I,C))throw new Error("bad point: equation left != right");if(!Z.isTorsionFree())throw new Error("bad point: not in prime-order subgroup");return!0});function M$(Z,I,C,z,j){return C=new k(J.mul(C.px,Z),C.py,C.pz),I=I$(z,I),C=I$(j,C),I.add(C)}class k{constructor(Z,I,C){this.px=g("x",Z),this.py=g("y",I,!0),this.pz=g("z",C),Object.freeze(this)}static fromAffine(Z){let{x:I,y:C}=Z||{};if(!Z||!J.isValid(I)||!J.isValid(C))throw new Error("invalid affine point");if(Z instanceof k)throw new Error("projective point not allowed");if(J.is0(I)&&J.is0(C))return k.ZERO;return new k(I,C,J.ONE)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static normalizeZ(Z){return O0(k,"pz",Z)}static fromBytes(Z){return _(Z),k.fromHex(Z)}static fromHex(Z){let I=k.fromAffine(W(m("pointHex",Z)));return I.assertValidity(),I}static fromPrivateKey(Z){let I=g0(G,Q.allowedPrivateKeyLengths,Q.wrapPrivateKey);return k.BASE.multiply(I(Z))}static msm(Z,I){return S0(k,G,Z,I)}precompute(Z=8,I=!0){if(p.setWindowSize(this,Z),!I)this.multiply(w$);return this}_setWindowSize(Z){this.precompute(Z)}assertValidity(){t(this)}hasEvenY(){let{y:Z}=this.toAffine();if(!J.isOdd)throw new Error("Field doesn't support isOdd");return!J.isOdd(Z)}equals(Z){F(Z);let{px:I,py:C,pz:z}=this,{px:j,py:T,pz:B}=Z,U=J.eql(J.mul(I,B),J.mul(j,z)),A=J.eql(J.mul(C,B),J.mul(T,z));return U&&A}negate(){return new k(this.px,J.neg(this.py),this.pz)}double(){let{a:Z,b:I}=$,C=J.mul(I,w$),{px:z,py:j,pz:T}=this,B=J.ZERO,U=J.ZERO,A=J.ZERO,x=J.mul(z,z),w=J.mul(j,j),S=J.mul(T,T),O=J.mul(z,j);return O=J.add(O,O),A=J.mul(z,T),A=J.add(A,A),B=J.mul(Z,A),U=J.mul(C,S),U=J.add(B,U),B=J.sub(w,U),U=J.add(w,U),U=J.mul(B,U),B=J.mul(O,B),A=J.mul(C,A),S=J.mul(Z,S),O=J.sub(x,S),O=J.mul(Z,O),O=J.add(O,A),A=J.add(x,x),x=J.add(A,x),x=J.add(x,S),x=J.mul(x,O),U=J.add(U,x),S=J.mul(j,T),S=J.add(S,S),x=J.mul(S,O),B=J.sub(B,x),A=J.mul(S,w),A=J.add(A,A),A=J.add(A,A),new k(B,U,A)}add(Z){F(Z);let{px:I,py:C,pz:z}=this,{px:j,py:T,pz:B}=Z,U=J.ZERO,A=J.ZERO,x=J.ZERO,w=$.a,S=J.mul($.b,w$),O=J.mul(I,j),f=J.mul(C,T),E=J.mul(z,B),u=J.add(I,C),P=J.add(j,T);u=J.mul(u,P),P=J.add(O,f),u=J.sub(u,P),P=J.add(I,z);let b=J.add(j,B);return P=J.mul(P,b),b=J.add(O,E),P=J.sub(P,b),b=J.add(C,z),U=J.add(T,B),b=J.mul(b,U),U=J.add(f,E),b=J.sub(b,U),x=J.mul(w,P),U=J.mul(S,E),x=J.add(U,x),U=J.sub(f,x),x=J.add(f,x),A=J.mul(U,x),f=J.add(O,O),f=J.add(f,O),E=J.mul(w,E),P=J.mul(S,P),f=J.add(f,E),E=J.sub(O,E),E=J.mul(w,E),P=J.add(P,E),O=J.mul(f,P),A=J.add(A,O),O=J.mul(b,P),U=J.mul(u,U),U=J.sub(U,O),O=J.mul(u,f),x=J.mul(b,x),x=J.add(x,O),new k(U,A,x)}subtract(Z){return this.add(Z.negate())}is0(){return this.equals(k.ZERO)}multiply(Z){let{endo:I}=Q;if(!G.isValidNot0(Z))throw new Error("invalid scalar: out of range");let C,z,j=(T)=>p.wNAFCached(this,T,k.normalizeZ);if(I){let{k1neg:T,k1:B,k2neg:U,k2:A}=I.splitScalar(Z),{p:x,f:w}=j(B),{p:S,f:O}=j(A);z=w.add(O),C=M$(I.beta,x,S,T,U)}else{let{p:T,f:B}=j(Z);C=T,z=B}return k.normalizeZ([C,z])[0]}multiplyUnsafe(Z){let{endo:I}=Q,C=this;if(!G.isValid(Z))throw new Error("invalid scalar: out of range");if(Z===O$||C.is0())return k.ZERO;if(Z===k$)return C;if(p.hasPrecomputes(this))return this.multiply(Z);if(I){let{k1neg:z,k1:j,k2neg:T,k2:B}=I.splitScalar(Z),{p1:U,p2:A}=P0(k,C,j,B);return M$(I.beta,U,A,z,T)}else return p.wNAFCachedUnsafe(C,Z)}multiplyAndAddUnsafe(Z,I,C){let z=this.multiplyUnsafe(I).add(Z.multiplyUnsafe(C));return z.is0()?void 0:z}toAffine(Z){return K$(this,Z)}isTorsionFree(){let{isTorsionFree:Z}=Q;if(X===k$)return!0;if(Z)return Z(k,this);return p.wNAFCachedUnsafe(this,q).is0()}clearCofactor(){let{clearCofactor:Z}=Q;if(X===k$)return this;if(Z)return Z(k,this);return this.multiplyUnsafe(X)}toBytes(Z=!0){return A$("isCompressed",Z),this.assertValidity(),K(k,this,Z)}toRawBytes(Z=!0){return this.toBytes(Z)}toHex(Z=!0){return n(this.toBytes(Z))}toString(){return`<Point ${this.is0()?"ZERO":this.toHex()}>`}}k.BASE=new k($.Gx,$.Gy,J.ONE),k.ZERO=new k(J.ZERO,J.ONE,J.ZERO),k.Fp=J,k.Fn=G;let e=G.BITS,p=H0(k,Q.endo?Math.ceil(e/2):e);return k}function b0($){return Uint8Array.of($?2:3)}function e0($,Q,J={}){R$(Q,{hash:"function"},{hmac:"function",lowS:"boolean",randomBytes:"function",bits2int:"function",bits2int_modN:"function"});let G=Q.randomBytes||b$,X=Q.hmac||((z,...j)=>_$(Q.hash,z,h(...j))),{Fp:q,Fn:Y}=$,{ORDER:M,BITS:N}=Y;function D(z){let j=M>>k$;return z>j}function K(z){return D(z)?Y.neg(z):z}function W(z,j){if(!Y.isValidNot0(j))throw new Error(`invalid signature ${z}: out of range 1..CURVE.n`)}class V{constructor(z,j,T){if(W("r",z),W("s",j),this.r=z,this.s=j,T!=null)this.recovery=T;Object.freeze(this)}static fromCompact(z){let j=Y.BYTES,T=m("compactSignature",z,j*2);return new V(Y.fromBytes(T.subarray(0,j)),Y.fromBytes(T.subarray(j,j*2)))}static fromDER(z){let{r:j,s:T}=a.toSig(m("DER",z));return new V(j,T)}assertValidity(){}addRecoveryBit(z){return new V(this.r,this.s,z)}recoverPublicKey(z){let j=q.ORDER,{r:T,s:B,recovery:U}=this;if(U==null||![0,1,2,3].includes(U))throw new Error("recovery id invalid");if(M*p0<j&&U>1)throw new Error("recovery id is ambiguous for h>1 curve");let x=U===2||U===3?T+M:T;if(!q.isValid(x))throw new Error("recovery id 2 or 3 invalid");let w=q.toBytes(x),S=$.fromHex(h(b0((U&1)===0),w)),O=Y.inv(x),f=t(m("msgHash",z)),E=Y.create(-f*O),u=Y.create(B*O),P=$.BASE.multiplyUnsafe(E).add(S.multiplyUnsafe(u));if(P.is0())throw new Error("point at infinify");return P.assertValidity(),P}hasHighS(){return D(this.s)}normalizeS(){return this.hasHighS()?new V(this.r,Y.neg(this.s),this.recovery):this}toBytes(z){if(z==="compact")return h(Y.toBytes(this.r),Y.toBytes(this.s));if(z==="der")return D$(a.hexFromSig(this));throw new Error("invalid format")}toDERRawBytes(){return this.toBytes("der")}toDERHex(){return n(this.toBytes("der"))}toCompactRawBytes(){return this.toBytes("compact")}toCompactHex(){return n(this.toBytes("compact"))}}let R=g0(Y,J.allowedPrivateKeyLengths,J.wrapPrivateKey),L={isValidPrivateKey(z){try{return R(z),!0}catch(j){return!1}},normPrivateKeyToScalar:R,randomPrivateKey:()=>{let z=M;return B0(G(r$(z)),z)},precompute(z=8,j=$.BASE){return j.precompute(z,!1)}};function H(z,j=!0){return $.fromPrivateKey(z).toBytes(j)}function g(z){if(typeof z==="bigint")return!1;if(z instanceof $)return!0;let T=m("key",z).length,B=q.BYTES,U=B+1,A=2*B+1;if(J.allowedPrivateKeyLengths||Y.BYTES===U)return;else return T===U||T===A}function F(z,j,T=!0){if(g(z)===!0)throw new Error("first arg must be private key");if(g(j)===!1)throw new Error("second arg must be public key");return $.fromHex(j).multiply(R(z)).toBytes(T)}let K$=Q.bits2int||function(z){if(z.length>8192)throw new Error("input is too large");let j=U$(z),T=z.length*8-N;return T>0?j>>BigInt(T):j},t=Q.bits2int_modN||function(z){return Y.create(K$(z))},M$=G$(N);function k(z){return N0("num < 2^"+N,z,O$,M$),Y.toBytes(z)}function e(z,j,T=p){if(["recovered","canonical"].some((P)=>(P in T)))throw new Error("sign() legacy options not supported");let{hash:B}=Q,{lowS:U,prehash:A,extraEntropy:x}=T;if(U==null)U=!0;if(z=m("msgHash",z),w0(T),A)z=m("prehashed msgHash",B(z));let w=t(z),S=R(j),O=[k(S),k(w)];if(x!=null&&x!==!1){let P=x===!0?G(q.BYTES):x;O.push(m("extraEntropy",P))}let f=h(...O),E=w;function u(P){let b=K$(P);if(!Y.isValidNot0(b))return;let H$=Y.inv(b),W$=$.BASE.multiply(b).toAffine(),N$=Y.create(W$.x);if(N$===O$)return;let $$=Y.create(H$*Y.create(E+N$*S));if($$===O$)return;let g$=(W$.x===N$?0:2)|Number(W$.y&k$),z$=$$;if(U&&D($$))z$=K($$),g$^=1;return new V(N$,z$,g$)}return{seed:f,k2sig:u}}let p={lowS:Q.lowS,prehash:!1},Z={lowS:Q.lowS,prehash:!1};function I(z,j,T=p){let{seed:B,k2sig:U}=e(z,j,T);return Z0(Q.hash.outputLen,Y.BYTES,X)(B,U)}$.BASE.precompute(8);function C(z,j,T,B=Z){let U=z;j=m("msgHash",j),T=m("publicKey",T),w0(B);let{lowS:A,prehash:x,format:w}=B;if("strict"in B)throw new Error("options.strict was renamed to lowS");if(w!==void 0&&!["compact","der","js"].includes(w))throw new Error('format must be "compact", "der" or "js"');let S=typeof U==="string"||Z$(U),O=!S&&!w&&typeof U==="object"&&U!==null&&typeof U.r==="bigint"&&typeof U.s==="bigint";if(!S&&!O)throw new Error("invalid signature, expected Uint8Array, hex string or Signature instance");let f=void 0,E;try{if(O)if(w===void 0||w==="js")f=new V(U.r,U.s);else throw new Error("invalid format");if(S){try{if(w!=="compact")f=V.fromDER(U)}catch(z$){if(!(z$ instanceof a.Err))throw z$}if(!f&&w!=="der")f=V.fromCompact(U)}E=$.fromHex(T)}catch(z$){return!1}if(!f)return!1;if(A&&f.hasHighS())return!1;if(x)j=Q.hash(j);let{r:u,s:P}=f,b=t(j),H$=Y.inv(P),W$=Y.create(b*H$),N$=Y.create(u*H$),$$=$.BASE.multiplyUnsafe(W$).add(E.multiplyUnsafe(N$));if($$.is0())return!1;return Y.create($$.x)===u}return Object.freeze({getPublicKey:H,getSharedSecret:F,sign:I,verify:C,utils:L,Point:$,Signature:V})}function $J($){let Q={a:$.a,b:$.b,p:$.Fp.ORDER,n:$.n,h:$.h,Gx:$.Gx,Gy:$.Gy},J=$.Fp,G=X$(Q.n,$.nBitLength),X={Fp:J,Fn:G,allowedPrivateKeyLengths:$.allowedPrivateKeyLengths,allowInfinityPoint:$.allowInfinityPoint,endo:$.endo,wrapPrivateKey:$.wrapPrivateKey,isTorsionFree:$.isTorsionFree,clearCofactor:$.clearCofactor,fromBytes:$.fromBytes,toBytes:$.toBytes};return{CURVE:Q,curveOpts:X}}function JJ($){let{CURVE:Q,curveOpts:J}=$J($),G={hash:$.hash,hmac:$.hmac,randomBytes:$.randomBytes,lowS:$.lowS,bits2int:$.bits2int,bits2int_modN:$.bits2int_modN};return{CURVE:Q,curveOpts:J,ecdsaOpts:G}}function QJ($,Q){return Object.assign({},Q,{ProjectivePoint:Q.Point,CURVE:$})}function y0($){let{CURVE:Q,curveOpts:J,ecdsaOpts:G}=JJ($),X=t0(Q,J),q=e0(X,G,J);return QJ($,q)}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */function v0($,Q){let J=(G)=>y0({...$,hash:G});return{...J(Q),create:J}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */var E$={p:BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),n:BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),h:BigInt(1),a:BigInt(0),b:BigInt(7),Gx:BigInt("0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"),Gy:BigInt("0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8")},mJ=BigInt(0),GJ=BigInt(1),p$=BigInt(2),_0=($,Q)=>($+Q/p$)/Q;function qJ($){let Q=E$.p,J=BigInt(3),G=BigInt(6),X=BigInt(11),q=BigInt(22),Y=BigInt(23),M=BigInt(44),N=BigInt(88),D=$*$*$%Q,K=D*D*$%Q,W=l(K,J,Q)*K%Q,V=l(W,J,Q)*K%Q,R=l(V,p$,Q)*D%Q,L=l(R,X,Q)*R%Q,H=l(L,q,Q)*L%Q,g=l(H,M,Q)*H%Q,F=l(g,N,Q)*g%Q,K$=l(F,M,Q)*H%Q,t=l(K$,J,Q)*K%Q,M$=l(t,Y,Q)*L%Q,k=l(M$,G,Q)*D%Q,e=l(k,p$,Q);if(!n$.eql(n$.sqr(e),$))throw new Error("Cannot find square root");return e}var n$=X$(E$.p,void 0,void 0,{sqrt:qJ}),L$=v0({...E$,Fp:n$,lowS:!0,endo:{beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),splitScalar:($)=>{let Q=E$.n,J=BigInt("0x3086d221a7d46bcde86c90e49284eb15"),G=-GJ*BigInt("0xe4437ed6010e88286f547fa90abfe4c3"),X=BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),q=J,Y=BigInt("0x100000000000000000000000000000000"),M=_0(q*$,Q),N=_0(-G*$,Q),D=d($-M*J-N*X,Q),K=d(-M*G-N*q,Q),W=D>Y,V=K>Y;if(W)D=Q-D;if(V)K=Q-K;if(D>Y||K>Y)throw new Error("splitScalar: Endomorphism failed, k="+$);return{k1neg:W,k1:D,k2neg:V,k2:K}}}},Y0);function lJ(){let $=L$.utils.randomPrivateKey(),Q=L$.getPublicKey($),J=new Uint8Array(32).fill(1),G=L$.sign(J,$),X=L$.verify(G,J,Q)===!0;console.info(G),console.info(X)}export{lJ as test};
